*1. Напишите программу, которая принимает группу чисел от пользователя и
помещает их в массив типа float. После того как числа будут помещены в
массив, программа должна подсчитать их среднее арифметическое и вывес-
ти результат на дисплей. Используйте указатели везде, где только возможно.
*2. Используйте класс String из примера NEWSTR этой главы. Добавьте к нему
метод upit(), который будет переводить символы строки в верхний регистр.
Вы можете использовать библиотечную функцию toupper(), которая прини-
мает отдельный символ в качестве аргумента и возвращает символ, пере-
веденный в верхний регистр (если это необходимо). Эта функция исполь-
 
зует заголовочный файл Cctype. Добавьте в функцию main() необходимые
строки для тестирования метода upit().
*3. Используйте массив указателей на строки, представляющие собой назва-
ния дней недели, из примера PTROSTR этой главы. Напишите функции для
сортировки этих строк в алфавитном порядке, используя в качестве осно-
вы функции bsort() и order() из программы PTRSORT этой главы. Сортиро-
вать необходимо указатели на строки, а не сами строки.
*4. Добавьте деструктор в программу LINKLIST. Он должен удалять все эле-
менты списка при удалении объекта класса linklist. Элементы должны
удаляться по очереди, в соответствии с их расположением в списке. Про-
тестируйте деструктор путем вывода сообщения об удалении каждого из
элементов списка; удалено должно быть также количество элементов, ка-
кое было положено в список (деструктор вызывается автоматически для
каждого существующего объекта).
5.	Предположим, что в функции main() определены три локальных массива
одинакового размера и типа (скажем, float). Первые два уже инициализи-
рованы значениями. Напишите функцию addarrays(), которая принимает в
качестве аргументов адреса грех массивов, складывает соответствующие
элементы двух массивов и помещает результат в третий массив. Четвертым
аргументом этой функции может быть размерность массивов. На всем
протяжении программы используйте указатели.
6.	Создайте свою версию библиотечной функции strcmp(s1, s2), которая срав-
нивает две строки и возвращает -1, если s1 идет первой по алфавиту, 0,
если в s1 и s2 одинаковые значения, и 1, если s2 идет первой по алфавиту.
Назовите вашу функцию compstr(). Она должна принимать в качестве ар-
гументов два указателя на строки char*, сравнивать эти строки посим-
вольно и возвращать число int. Напишите функцию main() для проверки
работы вашей функции с разными строками. Используйте указатели во
всех возможных ситуациях.
7.	Модифицируйте класс person из программы PERSORT этой главы так, что-
бы он включал в себя не только имя человека, но и сведения о его зарпла-
те в виде поля salary типа float. Вам будет необходимо изменить методы
setName() и printName() на setData() и printData(), включив в них возмож-
ность ввода и вывода значения salary, как это можно сделать с именем.
Вам также понадобится метод getSalary(). Используя указатели, напишите
функцию salsort(), которая сортирует указатели массива persPtr по значе-
ниям зарплаты. Попробуйте вместить всю сортировку в функцию salsort(),
не вызывая других функций, как это сделано в программе PERSORT. При
этом не забывайте, что операция -> имеет больший приоритет, чем опера-
ция *, и вам нужно будет написать
if((*(pp + j))->getSalary() > (*(pp + k))->getSalary())
  { /* меняем указатели местами */ }
8.	Исправьте функцию additem() из программы LINKLIST так, чтобы она до-
бавляла новый элемент в конец списка, а не в начало. Это будет означать,
 
что первый вставленный элемент будет выведен первым и результат рабо-
ты программы будет следующим:
25
36
49
64
Для того чтобы добавить элемент, вам необходимо будет пройти по цепи
до конца списка, а затем изменить указатель последнего элемента так, что-
бы он указывал на новый элемент.
9.	Допустим, что нам нужно сохранить 100 целых чисел так, чтобы иметь к
ним легкий доступ. Допустим, что при этом у нас есть проблема: память
нашего компьютера так фрагментирована, что может хранить массив, наи-
большее количество элементов в котором равно десяти (такие проблемы
действительно появляются, хотя обычно это происходит с объектами, зани-
мающими большое количество памяти). Вы можете решить эту проблему,
определив 10 разных массивов по 10 элементов в каждом и массив из
10 указателей на эти массивы. Массивы будут иметь имена a0, a1, a2 и т. д.
Адрес каждого массива будет сохранен в массиве указателей типа int*, ко-
торый называется ар. Вы сможете получить доступ к отдельному целому
используя выражение ap[j][к], где j является номером элемента массива
указателей, а к — номером элемента в массиве, на который этот указатель
указывает. Это похоже на двумерный массив, но в действительности яв-
ляется группой одномерных массивов.
Заполните группу массивов тестовыми данными (скажем, номерами 0, 10,
20 и т. д.), а затем выведите их, чтобы убедиться, что все работает пра-
вильно.
