*1.	Представьте себе издательскую компанию, которая торгует книгами и
	аудио-записями этих книг. Создайте класс publication, в котором хранятся
	название (строка) и цена (типа float) книги. От этого класса наследуются
	еще два класса: book, который содержит информацию о количестве страниц
	в книге (типа int), и type, который содержит время записи книги в минутах
	(тип float). В каждом из этих трех классов должен быть метод getdata(),
	через который можно получать данные от пользователя с клавиатуры,
	и putdata(), предназначенный для вывода этих данных.
	Напишите функцию main() программы для проверки классов book и type.
	Создайте их объекты в программе и запросите пользователя ввести и вы-
	вести данные с использованием методов getdata() и putdata().
*2. Вспомните пример STRCONV из главы 8. Класс String в этом примере имеет
	дефект: у него нет защиты на тот случай, если его объекты будут инициа-
	лизированы слишком длинной строкой (константа SZ имеет значение 80).
	Например, определение
	String s = "Эта строка имеет очень большую длину и мы можем быть уверены, что она не
	уместится в отведенный буфер, что приведет к непредсказуемым последствиям.";
будет причиной переполнения массива str строкой s с непредсказуемыми
последствиями вплоть до краха системы.
Создадим класс Pstring, производный от класса String, в котором предот-
вратим возможность переполнения буфера при определении слишком
длинной строковой константы. Новый конструктор производного класса
будет копировать в str только SZ-1 символов, если строка окажется слиш-
ком длинной, и будет копировать строку полностью, если она будет иметь
длину меньшую, чем SZ. Напишите функцию main() программы для про-
верки ее работы со строками разной длины.
 
*3. Начните с классов book, type и publication из упражнения 1. Добавьте базо-
вый класс sales, в котором содержится массив, состоящий из трех значе-
ний типа float, куда можно записать общую стоимость проданных книг за
последние три месяца. Включите в класс методы getdata() для получения
значений стоимости от пользователя и putdata() для вывода этих цифр.
Измените классы book и type так, чтобы они стали производными обоих
классов: publications и sales. Объекты классов book и type должны вводить
и выводить данные о продажах вместе с другими своими данными. Напи-
шите функцию main() для создания объектов классов book и type, чтобы
протестировать возможности ввода/вывода данных.
4.	Предположим, что издатель из упражнений 1 и 3 решил добавить к своей
продукции версии книг на компьютерных дисках для тех, кто любит чи-
тать книги на своих компьютерах. Добавьте класс disk, который, как book
и type, является производным класса publication. Класс disk должен вклю-
чать в себя те же функции, что и в других классах. Полем только этого
класса будет тип диска: CD или DVD. Для хранения этих данных вы мо-
жете ввести тип enum. Пользователь должен выбрать подходящий тип, на-
брав на клавиаtype с или d.
5.	Создайте производный класс employee2 от базового класса employee из
программы EMPLOY этой главы. Добавьте в новый класс поле compensation
типа double  и поле period типа enum для обозначения периода оплаты ра-
боты служащего: почасовая, понедельная или помесячная. Для простоты
вы можете изменить классы laborer, manager и scientist так, чтобы они ста-
ли производными нового класса employee2. Однако заметим, что во мно-
гих случаях создание отдельного класса compensation и трех его производ-
ных классов manager2, scientist2 и laborer2 более соответствовало бы духу
ООП. Затем можно применить множественное наследование и сделать
так, чтобы эти три новых класса стали производными класса compensation
и первоначальных классов manager, scientist и laborer. Таким путем можно
избежать модификации исходных классов.
6.	Вспомним программу ARROVER3 из главы 8. Сохраним класс safearay таким
же и, используя наследование, добавим к нему возможность для пользо-
вателя определять верхнюю и нижнюю границы массива в конструкторе.
Это похоже на упражнение 9 из главы 8, за исключением того, что при-
менено наследование для создания нового класса (можно назвать его
safehilo) взамен модификации исходного класса.
7.	Вспомним программу COUNTEN2 из этой главы. В ней можно увеличивать
и уменьшать счетчик, используя префиксные операции. Используя насле-
дование, добавьте возможность использования постфиксных операций для
случаев увеличения и уменьшения. (Описание постфиксных операций вы
сможете найти в главе 8.)
8.	В некоторых компьютерных языках, таких, как Visual Basic, есть опера-
ции, с помощью которых можно выделить часть строки и присвоить ее
другой строке. (В стандартном классе string предложены различные под-
 
ходы.) Используя наследование, добавьте такую возможность в класс
Pstring из упражнения 2. В новом производном классе Pstring2 разместите
три новых функции: left(), mid() и right().
s2.left(s1, n)	// в строку s2 помещаются n самых левых
	// символов строки s1
s2.mid(s1, s, n)	// в строку s2 помещаются n символов из строки
	// начиная с символа номер s
s2.right(s1, n) 	// в строку s2 помещаются n самых правых
	// символов строки s1
Вы можете использовать цикл for для копирования символ за символом
подходящих частей строки s1 во временный объект класса Pstring2, кото-
рый затем их возвратит. Для получения лучшего результата используйте
в этих функциях возврат по ссылке, чтобы они могли быть использованы
с левой стороны знака «равно» для изменения части существующей строки.
