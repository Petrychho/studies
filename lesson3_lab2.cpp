#include <iostream>

int main(int argc, char const *argv[])
{
	long int tmp = 0x48656C6C6F; // "Hello"
	char ch;
// 1.
// Не понимаю почему компилятор ругается если сделать следующим образом: char *ptr_char = &tmp;
// т.е. сразу указываем нужный адрес с которого необходимо начать считывать информацию.
// Если логично подумать то компилятор пытается избежать выхода за пределы выделенной памяти, но если мы 
// берем самый маленький размер переменной в нашем случае char, то long int, да и любая перемменная,
// кроме bool, будет кратна 1 байту и за пределы выйти будет просто не возможно если знать размеры.

// 2.	
// Не понятно почему приходится подбирать число для смещения до нужного адреса
	char* ptr_char = &ch + sizeof(tmp) - 6;
	int cnt = 0;

	std::cout << "&tmp =\t" << &tmp << std::endl;
// 3.	
// Почему адреса char не выводятся на экран, только с помощью static_cast<void *>(ptr_char)?
	std::cout << "&ptr_char = " << static_cast<void *>(ptr_char)<< std::endl;

// 4.
// Не понимаю почему если структура (*ptr_char++) работает, то программа циклится если делать 
// while ((*ptr_char++) != &tmp), т.е. пока не дойдем до нужного адреса ?

	for (int i = 0; i < 5; ++i, (*ptr_char++))
	{
		std::cout << "ptr_char = " << *ptr_char << std::endl;
		for (char res = *ptr_char; res; res >>= 1)
		{
			cnt += ((res & 1) == 1);
		}
	}
	std::cout << "cnt = " << cnt << std::endl;

	return 0;
}
