#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Функция посчета слов в Словаре
// Структура Словаря должна быть следующая Слово - Описание
// Функция принемает файл f и возвращает кол-во слов в нем
int LotOfWord(FILE *f)
{
	// Переменная word отвечает за длинну слова и за спец символы разделения " - "
	// 128 символов - условия задания
	char word[128];
	// Переменная size счетчик слов в файле
	int size = 0;

	// Цикл чтения из файла "пока не конец файла"
	// в переменную word считывается строка размером 128 символов из файла 
	// или же до спец символа конца строки \n или конца файла
	// т.е. в word может быть помещенна строка размером меньше 128 символов
	while (fgets(word,128,f) != NULL)
	{
		// Цикл проверки каждого символа в массиве символов word
		for (int i = 0; i < 128; i++)
		{
			// Если текущий символ ревен пробелу, а следующие два равны тире и пробелу 
			if(word[i] == ' ' && word[i+1] == '-' && word[i+2] == ' ')
			{
				// Значит это было слово size увеличивается на один
				size++;
				// В ячейку с символом " " записывается 0 для предотвращения ложного 
				// срабатывания данного условия, так как массив word не переписывается полностью
				// и данные спец символы могут остаться в массиве пока не в него не запишется строка
				// равная или большая предыдущей
				word[i] = 0;
				// Выход из цикла т.к слово уже найденно и просматривать другие символы в строке
				// не имеет смысла
				break;
			}
			
		}
	}
	// Возвращается переменная size в которой находится кол-во слов из словаря
	return size;
};

// Функция переноса данных Слова и его Описания в память
// Функция принемает файл f, массив указателей memory_of_dictionary для записи в него Слова и Описания
// кол-во слов size и максимальную длинну Слова + Указателя length_of_discription
// Так как в функцию передается указатель на массив указателей, то работа с массивом memory_of_dictionary
// в функции происходит не с его копией, а с оригиналом 
void FileInToMemoty(FILE *f,char** memory_of_dictionary, int size, int length_of_discription)
{
	// Функция fseek позволяет начать считывать файл с самого начала
	fseek(f,0L,SEEK_SET);	

	// Цикл переноса Слова и его Описания в память
	// Пока не запишем все Слова в память
	for (int i = 0; i < size; i++)
	{
		// Считывается из файла f строка размером length_of_discription
		// и помещается в ячейку массива memory_of_dictionary[i]
		fgets(memory_of_dictionary[i],length_of_discription,f);
	}
};

// Функция вывода на экран Слов
// Функция принемает массив указателей memory_of_dictionary и кол-во Слов size
// Так как в функцию передается указатель на массив указателей, то работа с массивом memory_of_dictionary
// в функции происходит не с его копией, а с оригиналом 
void PrintDictionary(char** memory_of_dictionary, int size)
{
	char ch;
	printf("Хотети вывести все слова или одно?(A/O): ");
	scanf("%c",&ch);
	scanf("%c",&ch);

	if (ch == 'A')
	{
		// Цикл вывода на экран всех Слов 
		for (int i = 0; i < size; i++)
		{
		// Условие если в memory_of_dictionary[i] есть строка
		if(memory_of_dictionary[i] != NULL)
			// То строка выводится на экран
			printf("%s", memory_of_dictionary[i]);
		}
	}
	if (ch == 'O')
	{
		// В переменную word записывается слово веденное пользователем
		char word[128];

		// Предлагает ввести строку - слово, которое необходимо найти в памяти
		// Введенное слово записывается в массив символов word
		printf("Введите слово которое нужно найти: ");
		scanf("%s",word);

		// Цикл поиска слова в Словаре
		for (int i = 0; i < size; i++)
		{
			// Условия сравнения слова записанного слова в массив word
			// со Словами в памяти
			// Функция strncmp сравнивает массивы word и memory_of_dictionary[i]
			// длинною strlen(word) и возвращает 0 если они равны, т.е. слово найдено в словаре
			if (strncmp(word, memory_of_dictionary[i],strlen(word)) == 0)
			{
				// Условие если в memory_of_dictionary[i] есть строка
				if(memory_of_dictionary[i] != NULL)
				{
					// То строка выводится на экран
					printf("%s", memory_of_dictionary[i]);
					break;
				}
			}
		}
		printf("Слово %s не найдено\n", word);
	}	
};

// Функция удаления Слова и его Описания из памяти (из Словаря)
// Функция принемает массив указателей memory_of_dictionary и кол-во Слов size
// Так как в функцию передается указатель на массив указателей, то работа с массивом memory_of_dictionary
// в функции происходит не с его копией, а с оригиналом 
void DeleteFromMemory(char** memory_of_dictionary, int size)
{
	// Переменная word отвечает за длинну слова
	char word[128];

	// Предлагает ввести строку - слово, которое необходимо удалить из памяти
	// Введенное слово записывается в массив символов word
	printf("Введите слово которое нужно удалить: ");
	scanf("%s",word);
	
	// Цикл поиска слова в Словаре
	for (int i = 0; i < size; i++)
	{
		// Условия сравнения слова записанного слова в массив word
		// со Словами в памяти
		// Функция strncmp сравнивает массивы word и memory_of_dictionary[i]
		// длинною strlen(word) и возвращает 0 если они равны, т.е. слово найдено в словаре
		if (strncmp(word, memory_of_dictionary[i],strlen(word)) == 0)
		{
			// Освобождается память ячейки массива memory_of_dictionary[i] 
			free(memory_of_dictionary[i]);
			// Указателю данной ячейки присвается значение NULL, т.е он больше никуда не указывает
			// Это делается чтобы исключить работу с памятью, с которой уже работать не нужно
			memory_of_dictionary[i] = NULL;
		}
	}
};

// Функция добавления новых Слов в память 
// Функция принемает массив указателей memory_of_dictionary, кол-во Слов, которые были до добавления - size
// и кол-во Слов, которые необходимо добавить  - new_size
// Так как в функцию передается указатель на массив указателей, то работа с массивом memory_of_dictionary
// в функции происходит не с его копией, а с оригиналом 
void AddToMemory(char** memory_of_dictionary, int size, int new_size)
{
	// Массив символов в который записывается Слово и его Описание 
	char mass[500];
	// Не нужная строчка, но почему то без нее не срабатывает fgets внутри цикла for
	fgets(mass, 500, stdin);
	// Цикл добавления новых слов в память
	// Т.к. массив указателей увеличился, а все Слова до этого момента хранящиеся в нем необходимо сохранить
	// то зпись новых слов происходит в нововыделенные ячейки массива memory_of_dictionary
	// начиная с size и закаичвая size + new_size
	for (int i = size; i < (size + new_size); ++i)
	{
		// Предлагает пользвателю ввести слово в заданном формате
		printf("Введите слово и его описание в формате (Слово - Описание): ");
		// функция fgets помещает в ячейку memory_of_dictionary[i] строку, которая вводится пользоваелем,
		// до спец символа перехода на следующую строку \n
		fgets(memory_of_dictionary[i], 500, stdin);
	}
};


// Программа предлагает ввести имя файла где хранится Словарь
// после чего выделяет пямять под слова которые уже есть в Словере
// записывает слова в память и предлагает работать со Словарем
// с помощью инструкции.
// Все функции описанны в main.c для того что чтобы у меньшить кол-во
// файлов при передачи выполненной задачи и легче было ориентироваться в ней
// без подключения лишних заголовочных файлов
int main()
{
	// постоянная n отвечает за размер динамического массива memory_of_dictionary (128 + 472 символа)
	// 128 - размер слова, 472 - размер его описания
	const int n = 500;
	// переменная new_size отвечает за кол-во слов которые необходимо добавить в словаре
	int new_size = 0;
	// переменная ch отвечает за инструкции по работе со словарем
	char ch;
	// в переменную FileName записывается имя файла, откуда будет считан словарь
	char FileName[128];

	//Записываем имя файла в переменную FileName
	printf("Введите имя файла: ");
	scanf("%s", FileName);
	// открываем файл указанный в FileName на чтение
	FILE *in = fopen(FileName,"r");
	
	// Проверяем есть ли такой файл 
	// Если нет, то пишется сообщение об ошибке и закрывается программа
	if (!in){
		printf("Error can't open FILE\n"); exit(1);}

	// Выполняется фукция LotOfWord которая подсчитывает кол-во слов в файле
	// и возвращает это кол-во, которое записывается в size
	int size = LotOfWord(in);

	// Выделяется динамически память
	// Создается массив указателей memory_of_dictionary размером size слов каждое из которых имеет длинну n
	char** memory_of_dictionary = (char**)malloc(size * sizeof(char*));
	for (int i = 0; i < size; i++)
	{
		memory_of_dictionary[i] = (char*)malloc(n * sizeof(char));
	}


	// Функция FileInToMemoty записывает словарь в память
	// каждое слово и его описание помещается в свою ячейку массива memory_of_dictionary
	FileInToMemoty(in,memory_of_dictionary, size, n);
	// Послу загрузки всего файла в память закрывается файл
	fclose(in);


	// Инсрукции по работе в Словаре
	printf("Введите Е - что бы закончить работу с программой\n");
	printf("А - что бы добавить слово в словарь\n");
	printf("P - что бы напечатать словарь\n");
	printf("H - для помощи\n");
	printf("D - что бы удалить слово из словаря >> ");
	// Записывает символ введенный с клавиатуры в ch
	scanf("%c", &ch);

	// Цикл работы со Словарем в памяти "Пока ch не равно Е"
	do
	{	
		switch(ch)
		{
			// Инструкция по добавлению нового слова в словарь
			case 'A':
			{
				// Вводится кол-во слов которое необходимо добавить
				// После чего динамический массив memory_of_dictionary увеличивается на этот размер
				printf("Введите кол-во слов которое хотите добавить: ");
				scanf("%d", &new_size);
				// Если кол-во не введенно то пишется ошибка и завершается инструкция
				if (new_size == 0)
				{
					printf("Error the number of word = 0\n");
					break;
				}

				// Происходи перевыделение памяти массива memory_of_dictionary на new_size элементов длинной n
				// тоесть выделенная память будет равна new_size + new_size
				memory_of_dictionary = (char**)realloc(memory_of_dictionary,(size + new_size) * sizeof(char*));
				for (int i = size; i < (size + new_size); i++)
				{
					memory_of_dictionary[i] = (char*)malloc(n*sizeof(char));
				}

				// Запускается функция AddToMemory, которая предлагает пользователю ввести новое слово
				// и его описание, после чего записывает их в память
				AddToMemory(memory_of_dictionary, size, new_size);
				// size увеличивается на кол-во новых слов в словаре т.е. на new_size
				size += new_size;
				break;
			}
			// Инсрукция по выводу на экран Словаря
			case 'P':
			{
				// Функция PrintDictionary выводит на экран весь Словарь
				PrintDictionary(memory_of_dictionary,size);
				break;
			}
			// Инструкция по удалению слов из Словаря
			case 'D':
			{
				// Функция DeleteFromMemory предлагает пользователю ввести слово
				// которое необходимо удалить из Словаря и удаляет его в месте с описанием
				DeleteFromMemory(memory_of_dictionary, size);
				break;
			}
			// Инструкция с командами по работе со Словарем
			case 'H':
			{
				printf("Введите Е - что бы закончить работу с программой\n");
				printf("А - что бы добавить слово в словарь\n");
				printf("P - что бы напечатать словарь\n");
				printf("H - для справки\n");
				printf("D - что бы удалить слово из словаря");
			}
		}
		// Пользователь выбирает новую инструкцию и записывается она в ch
		printf(">> ");
		scanf("%c", &ch);
		// условия выхода из цикла, описанны выше перед do
	} while ((ch != 'E'));


	// Открывается файл на запись, в этот файл запишется сформированный Словарь
	in = fopen(FileName,"w");

	// Цикл по записи в файл, пока не пройдет все ячейки массива memory_of_dictionary
	for (int i = 0; i < size; ++i)
	{
		// Если указатель массива memory_of_dictionary указывает на что-то
		if (memory_of_dictionary[i] != NULL)
			// То записывается файл строка которая соответствует ячейке массива memory_of_dictionary
			fputs(memory_of_dictionary[i],in);
		// Если нет то счетчик i увеличивается на один
	}

	// Цикл по освобождению памяти массива memory_of_dictionary
	for (int i = 0; i < size; i++)
	{
		// Если указатель массива memory_of_dictionary указывает на что-то
		if (memory_of_dictionary[i] != NULL)
			// То освобождается память
			free(memory_of_dictionary[i]);
		// Если нет, i  увеличивается на один
	}
	// Освобождается память из под массива указателей
	free(memory_of_dictionary);
	// Закрывается файл
	fclose(in);
	return 0;
}